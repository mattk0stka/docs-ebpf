{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#codeblocks","title":"Codeblocks","text":"<p>some <code>code</code> here... some_basic_shit.c<pre><code>//\n// Created by mk0stka on 14.01.24.\n// (1)\n\n\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\n#define MAX_ENTRIES 10240\n#define TASK_COMM_LEN 16\n\nstruct event {\n    unsigned int pid;\n    unsigned int tpid;\n    int sig;\n    int ret;\n    char comm[TASK_COMM_LEN];\n};\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_ENTRIES);\n    __type(key, __u32);\n    __type(value, struct event);\n} values SEC(\".maps\");\n\nint hello(void *ctx) {\n\n    bpf_map_lookup_elem\n    return 0;\n}\n</code></pre></p> <ol> <li>:man_raising_hand: I'm an annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be expressed in Markdown.</li> </ol>"},{"location":"maps/","title":"Page 2","text":""},{"location":"maps/#another-heading","title":"Another heading","text":"trace_printk_example.c<pre><code>//\n// Created by mattk0stka on 16.01.24.\n//\n\n//go:build ignore\n\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\n\nSEC(\"kprobe/sys_execve\")\nint kprobe_execve(void *ctx) {\n\n    int pid = bpf_get_current_pid_tgid() &gt;&gt; 32;// (1)\n    const char fmt_str[] = \"Hack the planet!, my pid is %d\\n\";\n    bpf_trace_printk(fmt_str, sizeof(fmt_str), pid);\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <ol> <li>is a helper function that gets the ID of the process that triggered this eBPF program to run. It returns a 64-bit value with the process ID in the top 32 bits. The lower 32 bits are the thread group ID. For a single-threaded process, this is the same as the process ID, but additional threads for the process would be given different IDs.</li> </ol> <p>main.go<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"github.com/cilium/ebpf/link\"\n    \"github.com/cilium/ebpf/rlimit\"\n    \"log\"\n    \"os\"\n    \"time\"\n)\n\nfunc main() {\n    // Remove resource limits for kernels &lt;5.11.\n    if err := rlimit.RemoveMemlock(); err != nil {\n        log.Fatal(\"Removing memlock:\", err)\n    }\n\n    // Load the compiled eBPF ELF and load it into the kernel.\n    //var objs helloObjects\n    objs := helloObjects{}\n    if err := loadHelloObjects(&amp;objs, nil); err != nil {\n        log.Fatal(\"Loading eBPF objects:\", err)\n    }\n    defer objs.Close()\n\n    // name of the kernel function to trace\n    fn := \"sys_execve\"\n    kp, err := link.Kprobe(fn, objs.KprobeExecve, nil)\n    if err != nil {\n        log.Fatal(\"opening kprobe: %s\", err)\n    }\n\n    defer kp.Close()\n\n    filePath := \"/sys/kernel/debug/tracing/trace_pipe\"\n\n    // Open the trace_pipe file for reading\n    file, err := os.Open(filePath)\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // some code here, to print out trace_pipe ... \n}\n</code></pre> eBPF programs need to be attached to an event. For this example we chose to attach to the system call exeve, which is the syscall used to execute a program. Whenever anything or anyone starts aa new program executing on a this machine, that will call *execve(), which will trigger the eBPF program. </p> <p><code>bpf_trace_printk()</code> helper function in the kernel always sends output to the same predefind location: /sys/kernel/debug/tracing/trace_pipe. By using the <code>cat</code> command  you can confirm the content, for example: <pre><code> &lt;...&gt;-371439  [000] ...21 128224.956635: bpf_trace_printk: Hack the planet!, my pid is 371439\n &lt;...&gt;-371440  [005] ...21 128226.063314: bpf_trace_printk: Hack the planet!, my pid is 371440\n &lt;...&gt;-371440  [005] ...21 128226.065154: bpf_trace_printk: Hack the planet!, my pid is 371440\n bash-371441  [004] ...21 128226.067414: bpf_trace_printk: Hack the planet!, my pid is 371441\n &lt;...&gt;-371444  [007] ...21 128226.069998: bpf_trace_printk: Hack the planet!, my pid is 371444\n bash-371440  [005] ...21 128226.083741: bpf_trace_printk: Hack the planet!, my pid is 371440\n &lt;...&gt;-371450  [000] ...21 128226.103567: bpf_trace_printk: Hack the planet!, my pid is 371450\n</code></pre></p>"},{"location":"maps/array/","title":"BPF_MAP_TYPE_ARRAY","text":"<p><code>BPF_MAP_TYPE_ARRAY</code>provide generic array storage. The key type is an usinged 32-bit integer (4 bytes) and the map is of constant size. The size of the array is defined in <code>max_entries</code> at creation time. All array elements are pre-allocated and zero initalized when created. <code>BPF_MAP_TYPE_ARRAY</code> uses the same memory region for each CPU. The value stored can be of any size, however, all array elements are aligned to 8 bytes.</p>"},{"location":"maps/array/#kernel-bpf","title":"Kernel BPF","text":"<p>This snippet shows howw to declase an array in a BPF program. <pre><code>struct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __type(key, u32);\n    __type(value, long);\n    __uint(max_entries, 256);\n} my_map SEC(\".maps\");\n</code></pre></p>"},{"location":"maps/array/#example-implementation","title":"Example Implementation","text":"C v1C v2 pkt_counter.c<pre><code>//\n// Created by mattk0stka on 17.01.24.\n//\n\n//go:build ignore\n\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __type(key, __u32);\n    __type(value, __u64);\n    __uint(max_entries, 1);\n} pkt_count SEC(\".maps\");\n\nSEC(\"xdp\")\nint count_packets() {\n\n    __u32 key = 0;\n    __u64 *count =bpf_map_lookup_elem(&amp;pkt_count, &amp;key);\n\n    if (count) {\n        __sync_fetch_and_add(count, 1);\n    }\n\n    return XDP_PASS;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> pkt_counter.c<pre><code>//\n// Created by mattk0stka on 17.01.24.\n//\n\n//go:build ignore\n\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __type(key, __u32);\n    __type(value, __u64);\n    __uint(max_entries, 1);\n} pkt_count SEC(\".maps\");\n\nSEC(\"xdp\")\nint count_packets_v2() {\n\n    __u32 key = 0;\n    __u64 init = 1, *count;\n\n    count = bpf_map_lookup_elem(&amp;pkt_count, &amp;key);\n\n    if (!count) {\n    bpf_map_update_elem(&amp;pkt_count, &amp;key, &amp;init, BPF_ANY);\n    return 0;\n    }\n\n    __sync_fetch_and_add(count, 1);\n\n    return XDP_PASS;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre>"},{"location":"maps/array/#bpf_map_lookup_elem","title":"bpf_map_lookup_elem()","text":"<p>void *bpf_map_lookup_elem(struct bpf_map *map, const void *key)</p> <p>Array elements can be retrieved using the <code>bpf_map_lookup_elem()</code> helper. This helper returns a pointer into the array element, so to avoid data races with user-space reading the value, the user must use primitices like <code>__sync_fetch_and_add()</code> when updating the value in-place.</p>"},{"location":"maps/array/#bpf_map_update_elem","title":"bpf_map_update_elem()","text":"<p>long bpf_map_update_elem(struct bpf_map *map, const void *key, const void *value, u64 flags)</p> <p>Array elements can be updated using the <code>bpf_map_update_elem()</code> helper. <code>bpf_map_update_elem()</code> returns 0 on success, or negative error in case of failure.</p>"},{"location":"maps/array/#concurrency","title":"Concurrency","text":"<p>something to add here.....</p> main.go<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"github.com/cilium/ebpf/link\"\n    \"github.com/cilium/ebpf/rlimit\"\n    \"log\"\n    \"net\"\n    \"os\"\n    \"os/signal\"\n    \"time\"\n)\n\nfunc main() {\n    // Remove resource limits for kernels &lt;5.11.\n    if err := rlimit.RemoveMemlock(); err != nil { // (1)!\n        log.Fatal(\"Removing memlock:\", err)\n    }\n\n    // Load the compiled eBPF ELF and load it into the kernel.\n    var objs pkt_counterObjects // (2)!\n    if err := loadPkt_counterObjects(&amp;objs, nil); err != nil {\n        log.Fatal(\"Loading eBPF objects:\", err)\n    }\n    defer objs.Close() // (3)!\n\n    ifname := \"ens33\" // Change this to an interface on your machine.\n    iface, err := net.InterfaceByName(ifname)\n    if err != nil {\n        log.Fatalf(\"Getting interface %s: %s\", ifname, err)\n    }\n\n    // Attach count_packets to the network interface.\n    link, err := link.AttachXDP(link.XDPOptions{ // (4)!\n        Program:   objs.CountPackets,\n        Interface: iface.Index,\n    })\n    if err != nil {\n        log.Fatal(\"Attaching XDP:\", err)\n    }\n    defer link.Close() // (5)!\n\n    log.Printf(\"Counting incoming packets on %s..\", ifname)\n\n    // Periodically fetch the packet counter from PktCount,\n    // exit the program when interrupted.\n    tick := time.Tick(time.Second)\n    stop := make(chan os.Signal, 5)\n    signal.Notify(stop, os.Interrupt)\n    for {\n        select {\n        case &lt;-tick:\n            var count uint64\n            err := objs.PktCount.Lookup(uint32(0), &amp;count) // (6)!\n            if err != nil {\n                log.Fatal(\"Map lookup:\", err)\n            }\n            log.Printf(\"Received %d packets\", count)\n        case &lt;-stop:\n            log.Print(\"Received signal, exiting..\")\n            return\n        }\n    }\n}\n</code></pre>"},{"location":"maps/hash/","title":"BPF_MAP_TYPE_HASH","text":"<p><code>BPF_MAP_TYPE_HASH</code> provide general purpose hash map storage. Both the key and the value can be <code>struct</code>, allowing for composite keys and values.</p> <p>The kernel is responsible for allocating and freeing key/value pairs, up to the <code>max_entries</code> limit that you specify. Hash maps use pre-allocation of hash tables elements by default. <code>BPF_F_NO_PREALLOC</code> flag can be used to disbale pre-allocation when it is to memory expensive.</p> <pre><code>//\n// Created by mattk0stka on 19.01.24.\n//\n\n//go:build ignore\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\n#define MAX_MAP_ENTRIES 16\n\nstruct ethhdr {\n    unsigned char h_dest[6];\n    unsigned char h_source[6];\n    __be16 h_proto;\n};\n\nstruct counter {\n    __u32 count;\n    unsigned char h_source[6];\n};\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_LRU_HASH);\n    __uint(max_entries, MAX_MAP_ENTRIES);\n    __type(key, __u32);\n    __type(value, struct counter);\n} xdp_stats_map SEC(\".maps\");\n\n\nSEC(\"xdp\")\nint xdp_prog_func(struct xdp_md *ctx) {\n\n    void *data = (void *)(long) ctx-&gt;data;\n    void *data_end = (void *) (long) ctx-&gt;data_end;\n\n    struct ethhdr *eth = data;\n    if ((void *) (eth + 1) &gt; data_end) {\n        return 0;\n    }\n\n    struct counter *c = bpf_map_lookup_elem(&amp;xdp_stats_map, eth-&gt;h_source);\n    if (!c) {\n\n        struct counter cu = {1};\n        bpf_probe_read_kernel(&amp;cu.h_source, sizeof(cu.h_source), eth-&gt;h_source);\n        bpf_map_update_elem(&amp;xdp_stats_map, eth-&gt;h_source, &amp;cu, BPF_ANY);\n    } else {\n\n        __sync_fetch_and_add(&amp;c-&gt;count, 1);\n    }\n    return XDP_PASS;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <pre><code>2024/01/23 17:11:17 Map contents:\n        3e:22:fb:3a:69:65 =&gt; 7666\n        00:50:56:ed:15:fa =&gt; 40428\n2024/01/23 17:11:18 Map contents:\n        3e:22:fb:3a:69:65 =&gt; 7682\n        00:50:56:ed:15:fa =&gt; 40428\n2024/01/23 17:11:19 Map contents:\n        3e:22:fb:3a:69:65 =&gt; 7698\n        00:50:56:ed:15:fa =&gt; 40430\n2024/01/23 17:11:20 Map contents:\n        3e:22:fb:3a:69:65 =&gt; 7714\n        00:50:56:ed:15:fa =&gt; 42194\n^C2024/01/23 17:11:21 Received signal, exiting..\n</code></pre>"},{"location":"maps/perf/","title":"BPF_MAP_TYPE_PERF_EVENT_ARRAY","text":"<p>These types of maps store <code>perf_events</code> data in a buffer ring that communicates between BPF programs and user-space programs in real time. They are defined with thy type <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>. They are designed to forward events that the kernels's tracing tools emit to user-space programs for further processing. This is the base for many observability tools. The user-space program acts as a listener that waits for events coming from the kernel, so you need to make sure that the code starts listening before the BPF program in the kernek is initialized.</p> gen.go<pre><code>//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target amd64 -type event bash uretprobe_bash.c -- -I../headers\n</code></pre>"},{"location":"maps/perf/#vmlinuxh","title":"vmlinux.h","text":"<p>vmlinux.h is generated code. It contains all the type definitions that your running Linux kernel uses in its own source code. There's a tool, aptly names <code>bpftool</code>, that is maintained within the Linux repository. It has a feature to read the vmlinux object file and generate a vmlinux.h</p> <pre><code>$ bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h\n</code></pre> uretprobe_bash.c<pre><code>//\n// Created by mattk0stka on 27.01.24.\n//\n\n//go:build ignore\n\n#include \"headers/vmlinux.h\"\n\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n\nstruct event {\n    __u32 pid;\n    __u8 line[80];\n};\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n} events SEC(\".maps\");\n\nconst struct event *unused __attribute__((unused));\n\nSEC(\"uretprobe/bash_readline\")\nint uretprobe_bash_readline(struct pt_regs *ctx) {\n    struct event event;\n\n    event.pid = bpf_get_current_pid_tgid();\n    //bpf_probe_read(&amp;event.line, sizeof(event.line), (void *)PT_REGS_RC(ctx));\n    bpf_probe_read_user(&amp;event.line, sizeof(event.line), (void *)PT_REGS_RC(ctx));\n\n    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\n\n    return 0;\n}\n\nchar __license[] SEC(\"license\") = \"Dual MIT/GPL\";\n</code></pre> <pre><code>2024/01/27 21:33:15 Listening for events..\n2024/01/27 21:33:26 /bin/bash:readline return value: exit\n2024/01/27 21:33:32 /bin/bash:readline return value: ls -la\n2024/01/27 21:33:37 /bin/bash:readline return value: cd ..\n2024/01/27 21:33:45 /bin/bash:readline return value: ls -lh\n</code></pre>"},{"location":"xdp/","title":"XDP (eXpress Data Path)","text":"<p>XDP ist an eBPF-based high-performance data path used to send and receive network packets at high rates by bypassing most of the operationg system networking stack.</p> <pre><code>struct xdp_md {\n    __u32 data;\n    __u32 data_end;\n    __u32 data_meta;\n    __u32 ingress_ifindex;\n    __u32 rx_queue_index;\n    __u32 egress_ifindex;\n};\n</code></pre>"},{"location":"xdp/ethernet/","title":"Ethernet","text":"<pre><code>#define ETH_P_IP 0x0800\n\n// Ethernet Header Frame\nstruct ethhdr {\n    unsigned char h_dest[6];\n    unsigned char h_source[6];\n    __be16 h_proto;\n};\n</code></pre>"},{"location":"xdp/ipv4/","title":"IPv4","text":"<pre><code>struct iphdr {\n    __u8 ihl: 4;\n    __u8 version: 4;\n    __u8 tos;\n    __be16 tot_len;\n    __be16 id;\n    __be16 frag_off;\n    __u8 ttl;\n    __u8 protocol;\n    __sum16 check;\n    __be32 saddr;\n    __be32 daddr;\n};\n</code></pre>"}]}